<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèì 3D Ping Pong Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a3e 0%, #0a0a1a 100%);
            color: white;
            overflow: hidden;
            cursor: none;
        }
        
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Custom Cursor */
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #00f5ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: transform 0.1s, border-color 0.2s;
            box-shadow: 0 0 10px #00f5ff, inset 0 0 5px rgba(0,245,255,0.3);
        }
        
        #custom-cursor.hitting {
            transform: translate(-50%, -50%) scale(1.5);
            border-color: #ff00ff;
            box-shadow: 0 0 20px #ff00ff;
        }
        
        #menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: rgba(10, 10, 26, 0.97);
            backdrop-filter: blur(10px);
        }
        
        #menu-screen.hidden { display: none; }
        
        .title {
            font-size: 4rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00f5ff, #ff00ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0,245,255,0.5);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px #00f5ff); }
            to { filter: drop-shadow(0 0 40px #ff00ff); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 40px;
        }
        
        .menu-btn {
            display: block;
            width: 280px;
            padding: 18px 35px;
            margin: 12px;
            font-size: 1.3rem;
            font-weight: bold;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .menu-btn:hover {
            transform: scale(1.08) translateY(-3px);
        }
        
        .btn-bot {
            background: linear-gradient(135deg, #ff00ff, #ff0088);
            color: white;
            box-shadow: 0 5px 30px rgba(255, 0, 255, 0.5);
        }
        
        .btn-bot:hover {
            box-shadow: 0 10px 40px rgba(255, 0, 255, 0.7);
        }
        
        .btn-practice {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: black;
            box-shadow: 0 5px 30px rgba(0, 255, 136, 0.5);
        }
        
        .btn-practice:hover {
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.7);
        }
        
        .btn-online {
            background: linear-gradient(135deg, #00f5ff, #0088ff);
            color: black;
            box-shadow: 0 5px 30px rgba(0, 245, 255, 0.5);
        }
        
        .btn-online:hover {
            box-shadow: 0 10px 40px rgba(0, 245, 255, 0.7);
        }
        
        #game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 50;
            display: none;
            pointer-events: none;
        }
        
        #game-ui.active { display: block; }
        
        #score-board {
            display: flex;
            justify-content: center;
            gap: 80px;
            padding: 25px;
            font-size: 1.8rem;
        }
        
        .score { 
            text-align: center;
            padding: 15px 30px;
            border-radius: 15px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
        }
        
        .score-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0.8;
        }
        
        .score-value {
            font-size: 3.5rem;
            font-weight: bold;
            text-shadow: 0 0 20px currentColor;
        }
        
        .p1 { color: #00f5ff; border: 2px solid rgba(0,245,255,0.3); }
        .p2 { color: #ff00ff; border: 2px solid rgba(255,0,255,0.3); }
        
        /* Spin Indicator */
        #spin-indicator {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.2);
            z-index: 60;
            display: none;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        #spin-indicator.active { display: block; }
        
        #spin-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 6px;
            background: linear-gradient(90deg, #00f5ff, #ff00ff);
            transform-origin: left center;
            border-radius: 3px;
            box-shadow: 0 0 15px #00f5ff;
        }
        
        #spin-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #888;
        }
        
        /* Power Meter */
        #power-meter {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 30px;
            height: 150px;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.2);
            z-index: 60;
            display: none;
            background: rgba(0,0,0,0.5);
            overflow: hidden;
        }
        
        #power-meter.active { display: block; }
        
        #power-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #00ff88, #ffff00, #ff0000);
            transition: height 0.1s;
            box-shadow: 0 0 15px #00ff88;
        }
        
        #power-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #888;
        }
        
        /* Combo Counter */
        #combo {
            position: fixed;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 2rem;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            z-index: 60;
            display: none;
            animation: comboPulse 0.3s ease-out;
        }
        
        @keyframes comboPulse {
            0% { transform: translateY(-50%) scale(1.5); }
            100% { transform: translateY(-50%) scale(1); }
        }
        
        #message {
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            text-align: center;
            z-index: 60;
            display: none;
            text-shadow: 0 0 30px rgba(0,245,255,0.9);
            animation: msgAppear 0.3s ease-out;
        }
        
        @keyframes msgAppear {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        /* Tutorial */
        #tutorial {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #aaa;
            z-index: 55;
            display: none;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        #tutorial.active { display: block; }
        
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 3px 10px;
            border-radius: 5px;
            margin: 0 3px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .info {
            margin-top: 40px;
            color: #666;
            text-align: center;
            line-height: 2;
            font-size: 0.95rem;
        }
        
        .info strong {
            color: #00f5ff;
        }
        
        /* Hit Effect */
        .hit-effect {
            position: fixed;
            pointer-events: none;
            z-index: 500;
            animation: hitExpand 0.4s ease-out forwards;
        }
        
        @keyframes hitExpand {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="custom-cursor"></div>
    
    <div id="menu-screen">
        <h1 class="title">üèì PING PONG PRO</h1>
        <p class="subtitle">3D Masa Tenisi Sim√ºlasyonu</p>
        
        <button class="menu-btn btn-bot" id="btn-bot">ü§ñ Bota Kar≈üƒ±</button>
        <button class="menu-btn btn-practice" id="btn-practice">üéØ Antrenman</button>
        <button class="menu-btn btn-online" id="btn-online">üåê 2 Ki≈üilik</button>
        
        <div class="info">
            <strong>üñ±Ô∏è Fare Hareketi</strong> = Raket Kontrol√º<br>
            <strong>‚¨ÖÔ∏è Sola √áekerek Vur</strong> = Saƒüa Falso<br>
            <strong>‚û°Ô∏è Saƒüa √áekerek Vur</strong> = Sola Falso<br>
            <strong>‚¨ÜÔ∏è‚¨áÔ∏è Yukarƒ±/A≈üaƒüƒ±</strong> = Topspin/Backspin<br>
            <span class="key">SPACE</span> veya <span class="key">TIKLA</span> = Servis
        </div>
    </div>
    
    <div id="game-ui">
        <div id="score-board">
            <div class="score p1">
                <div class="score-label">Sen</div>
                <div class="score-value" id="score-p1">0</div>
            </div>
            <div class="score p2">
                <div class="score-label">Rakip</div>
                <div class="score-value" id="score-p2">0</div>
            </div>
        </div>
    </div>
    
    <div id="spin-indicator">
        <div id="spin-arrow"></div>
        <div id="spin-label">SPIN</div>
    </div>
    
    <div id="power-meter">
        <div id="power-fill"></div>
        <div id="power-label">G√ú√á</div>
    </div>
    
    <div id="combo"></div>
    <div id="message"></div>
    
    <div id="tutorial">
        <span class="key">SPACE</span> ile topu at, sonra <strong>raketinle vur!</strong>
    </div>
    
    <div id="pause-screen">
        <h2 style="font-size: 3rem; margin-bottom: 40px;">‚è∏Ô∏è DURAKLATILDI</h2>
        <button class="menu-btn btn-bot" id="btn-resume">‚ñ∂Ô∏è Devam Et</button>
        <button class="menu-btn btn-practice" id="btn-quit">üè† Ana Men√º</button>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script>
// ==================== 3D PING PONG ====================

let scene, camera, renderer;
let table, net, ball, paddle, opponentPaddle;
let gameState = 'menu';
let gameMode = 'bot';

// B√úY√úK MASA - daha fazla reaksiyon s√ºresi
const TABLE = { length: 5.0, width: 2.8, height: 0.76, netHeight: 0.16 };

// Fƒ∞Zƒ∞K - daha yava≈ü ve kontroll√º
const PHYSICS = { 
    gravity: -7,        // Yer√ßekimi
    ballRadius: 0.028, 
    paddleRadius: 0.12, // Daha b√ºy√ºk raket
    bounce: 0.82,
    airResistance: 0.998,
    magnusStrength: 0.5 // Falso etkisi
};

let ballPos = { x: 0, y: TABLE.height + 0.2, z: 0.8 };
let ballVel = { x: 0, y: 0, z: 0 };
let ballSpin = { x: 0, y: 0, z: 0 };

// SEKME SAYACI - masa tenisi kurallarƒ± i√ßin
let bounceCount = { player: 0, opponent: 0 };  // Her tarafta ka√ß kez sekti
let lastBounceZone = null;  // 'player' veya 'opponent'
let lastHitter = null;      // Son vuran kim

let paddlePos = { x: 0, y: TABLE.height + 0.12, z: TABLE.length/2 + 0.2 };
let paddlePrev = { x: 0, y: TABLE.height + 0.12, z: TABLE.length/2 + 0.2 };
let paddleVel = { x: 0, y: 0, z: 0 };
let paddleAngleX = 0; // Saƒü-sol eƒüim
let paddleAngleY = 0; // ƒ∞leri-geri eƒüim

let oppPos = { x: 0, y: TABLE.height + 0.12, z: -TABLE.length/2 - 0.2 };

let mouse = { x: 0, y: 0, prevX: 0, prevY: 0 };
let mouseVel = { x: 0, y: 0 };
let scores = { player: 0, opponent: 0 };
let servingPlayer = 'player';
let servePhase = 0;
let audioCtx = null;

// ===== INIT =====
function init() {
    console.log('Init started');
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
    // Daha iyi kamera a√ßƒ±sƒ± - eƒüik ve yukarƒ±dan
    camera.position.set(0, TABLE.height + 2.2, TABLE.length/2 + 3.5);
    camera.lookAt(0, TABLE.height, -TABLE.length/5);
    
    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    
    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(3, 8, 5);
    light.castShadow = true;
    scene.add(light);
    
    createTable();
    createNet();
    createBall();
    createPaddles();
    createFloor();
    
    setupEvents();
    animate();
    
    console.log('Init complete');
}

function createTable() {
    const geo = new THREE.BoxGeometry(TABLE.width, 0.03, TABLE.length);
    const mat = new THREE.MeshStandardMaterial({ color: 0x0d6b32 });
    table = new THREE.Mesh(geo, mat);
    table.position.set(0, TABLE.height, 0);
    table.receiveShadow = true;
    scene.add(table);
    
    // Lines
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const centerLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.005, TABLE.length), lineMat);
    centerLine.position.set(0, TABLE.height + 0.02, 0);
    scene.add(centerLine);
}

function createNet() {
    // Posts
    const postGeo = new THREE.CylinderGeometry(0.01, 0.01, TABLE.netHeight);
    const postMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    [-1, 1].forEach(side => {
        const post = new THREE.Mesh(postGeo, postMat);
        post.position.set(side * (TABLE.width/2 + 0.02), TABLE.height + TABLE.netHeight/2, 0);
        scene.add(post);
    });
    
    // Net
    const netGeo = new THREE.BoxGeometry(TABLE.width + 0.04, TABLE.netHeight, 0.01);
    const netMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    net = new THREE.Mesh(netGeo, netMat);
    net.position.set(0, TABLE.height + TABLE.netHeight/2 + 0.015, 0);
    scene.add(net);
}

function createBall() {
    const geo = new THREE.SphereGeometry(PHYSICS.ballRadius, 32, 32);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.3 });
    ball = new THREE.Mesh(geo, mat);
    ball.castShadow = true;
    scene.add(ball);
}

function createPaddles() {
    // Raket y√ºzeyi
    const paddleGeo = new THREE.CylinderGeometry(PHYSICS.paddleRadius, PHYSICS.paddleRadius, 0.012, 32);
    
    // Player paddle - KIRMIZI
    const pMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
    paddle = new THREE.Mesh(paddleGeo, pMat);
    paddle.castShadow = true;
    
    // Raket kau√ßuk y√ºzeyi
    const rubberGeo = new THREE.CylinderGeometry(PHYSICS.paddleRadius - 0.005, PHYSICS.paddleRadius - 0.005, 0.004, 32);
    const rubberMat = new THREE.MeshStandardMaterial({ color: 0x880000 });
    const rubber1 = new THREE.Mesh(rubberGeo, rubberMat);
    rubber1.position.y = 0.006;
    paddle.add(rubber1);
    const rubber2 = new THREE.Mesh(rubberGeo, rubberMat);
    rubber2.position.y = -0.006;
    paddle.add(rubber2);
    
    // Player handle - RAKETLE Bƒ∞RLE≈ûƒ∞K (Y ekseninde, a≈üaƒüƒ±da)
    const handleGeo = new THREE.CylinderGeometry(0.014, 0.02, 0.13, 16);
    const handleMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
    const handle = new THREE.Mesh(handleGeo, handleMat);
    handle.position.y = -0.07; // Raketin altƒ±nda
    paddle.add(handle);
    
    // Sap kavrama
    const gripGeo = new THREE.CylinderGeometry(0.016, 0.016, 0.06, 16);
    const gripMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const grip = new THREE.Mesh(gripGeo, gripMat);
    grip.position.y = -0.1;
    paddle.add(grip);
    
    scene.add(paddle);
    
    // Opponent paddle - MAVƒ∞
    const oMat = new THREE.MeshStandardMaterial({ color: 0x0066cc });
    opponentPaddle = new THREE.Mesh(paddleGeo.clone(), oMat);
    opponentPaddle.castShadow = true;
    
    // Rakip kau√ßuk
    const oppRubberMat = new THREE.MeshStandardMaterial({ color: 0x003388 });
    const oppRubber1 = new THREE.Mesh(rubberGeo.clone(), oppRubberMat);
    oppRubber1.position.y = 0.006;
    opponentPaddle.add(oppRubber1);
    const oppRubber2 = new THREE.Mesh(rubberGeo.clone(), oppRubberMat);
    oppRubber2.position.y = -0.006;
    opponentPaddle.add(oppRubber2);
    
    // Rakip sap - YUKARI (bizden bakƒ±nca)
    const oppHandle = new THREE.Mesh(handleGeo.clone(), handleMat);
    oppHandle.position.y = 0.07;
    opponentPaddle.add(oppHandle);
    
    const oppGrip = new THREE.Mesh(gripGeo.clone(), gripMat);
    oppGrip.position.y = 0.1;
    opponentPaddle.add(oppGrip);
    
    scene.add(opponentPaddle);
}

function createFloor() {
    const geo = new THREE.PlaneGeometry(20, 20);
    const mat = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
    const floor = new THREE.Mesh(geo, mat);
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);
}

// ===== EVENTS =====
function setupEvents() {
    document.addEventListener('mousemove', (e) => {
        mouse.prevX = mouse.x;
        mouse.prevY = mouse.y;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        // Mouse hƒ±zƒ±nƒ± hesapla (falso i√ßin)
        mouseVel.x = (mouse.x - mouse.prevX) * 60;
        mouseVel.y = (mouse.y - mouse.prevY) * 60;
        
        // Custom cursor g√ºncelle
        const cursor = document.getElementById('custom-cursor');
        if (cursor) {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        }
    });
    
    document.addEventListener('click', () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (gameState === 'serving' && servingPlayer === 'player' && servePhase === 0) {
            tossBall();
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === ' ' && gameState === 'serving' && servingPlayer === 'player' && servePhase === 0) {
            tossBall();
        }
        if (e.key === 'Escape') togglePause();
    });
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// ===== GAME =====
function startGame() {
    console.log('Starting game');
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('game-ui').classList.add('active');
    
    scores = { player: 0, opponent: 0 };
    updateScore();
    servingPlayer = 'player';
    prepareServe();
}

function prepareServe() {
    gameState = 'serving';
    servePhase = 0;
    
    // Sekme saya√ßlarƒ±nƒ± sƒ±fƒ±rla
    bounceCount = { player: 0, opponent: 0 };
    lastBounceZone = null;
    lastHitter = null;
    
    if (servingPlayer === 'player') {
        ballPos = { 
            x: paddlePos.x, 
            y: paddlePos.y + 0.1, 
            z: paddlePos.z - 0.15 
        };
        ballVel = { x: 0, y: 0, z: 0 };
        ballSpin = { x: 0, y: 0, z: 0 };
        showMsg('üèì TIKLA veya SPACE = Servis!', 3000);
    } else {
        ballPos = { x: oppPos.x, y: TABLE.height + 0.2, z: -TABLE.length/2 + 0.3 };
        ballVel = { x: 0, y: 0, z: 0 };
        showMsg('ü§ñ Rakip servis...', 1000);
        setTimeout(() => { if (gameState === 'serving') opponentServe(); }, 1500);
    }
}

function tossBall() {
    servePhase = 1;
    ballVel = { x: 0, y: 3.5, z: -0.3 };
    playSound(400);
    showMsg('üéØ Raketinle vur!', 2000);
}

function playerServe() {
    servePhase = 2;
    gameState = 'playing';
    lastHitter = 'player';
    bounceCount = { player: 0, opponent: 0 };
    playSound(800);
    
    // Servis - UZAƒûA Gƒ∞TMELƒ∞
    const power = 3.5 + Math.abs(paddleVel.z) * 0.15;
    ballVel = {
        x: paddleVel.x * 0.5,
        y: 2.0,
        z: -power
    };
    ballSpin = { 
        x: -paddleVel.y * 0.3, 
        y: 0,
        z: -paddleVel.x * 0.35 
    };
}

function opponentServe() {
    servePhase = 2;
    gameState = 'playing';
    lastHitter = 'opponent';
    bounceCount = { player: 0, opponent: 0 };
    playSound(800);
    
    const targetX = (Math.random()-0.5) * TABLE.width * 0.4;
    ballVel = { 
        x: (targetX - ballPos.x) * 0.3, 
        y: -1.8, 
        z: 3.0 + Math.random() * 0.5 
    };
    ballSpin = { 
        x: (Math.random()-0.5) * 2, 
        y: 0,
        z: (Math.random()-0.5) * 2 
    };
}

function update(dt) {
    if (!dt || dt > 0.1) dt = 0.016;
    
    // Paddle - store previous
    paddlePrev.x = paddlePos.x;
    paddlePrev.y = paddlePos.y;
    paddlePrev.z = paddlePos.z;
    
    // ===== TAM Bƒ∞REBƒ∞R MOUSE TAKƒ∞Bƒ∞ =====
    // X: saƒü-sol - DOƒûRUDAN mouse pozisyonu
    const targetX = mouse.x * (TABLE.width/2 + 0.5);
    
    // Z: derinlik kontrol√º
    const minZ = TABLE.length/2 - 1.2;
    const maxZ = TABLE.length/2 + 0.6;
    const zRange = maxZ - minZ;
    const targetZ = maxZ - ((mouse.y + 1) / 2) * zRange;
    
    // Y: y√ºkseklik
    const targetY = TABLE.height + 0.15;
    
    // %100 TAKƒ∞P - mouse neredeyse raket orada
    paddlePos.x = targetX;
    paddlePos.y = targetY;
    paddlePos.z = targetZ;
    
    // Sƒ±nƒ±rlar
    paddlePos.x = Math.max(-TABLE.width/2 - 0.5, Math.min(TABLE.width/2 + 0.5, paddlePos.x));
    paddlePos.y = Math.max(TABLE.height + 0.05, Math.min(TABLE.height + 0.4, paddlePos.y));
    paddlePos.z = Math.max(minZ, Math.min(maxZ, paddlePos.z));
    
    // Hƒ±z hesapla (falso i√ßin)
    paddleVel.x = (paddlePos.x - paddlePrev.x) / dt;
    paddleVel.y = (paddlePos.y - paddlePrev.y) / dt;
    paddleVel.z = (paddlePos.z - paddlePrev.z) / dt;
    
    // ===== RAKET Eƒûƒ∞Mƒ∞ =====
    const targetAngleX = -mouseVel.x * 0.08; // Hareket y√∂n√ºne g√∂re eƒüim
    const targetAngleY = mouseVel.y * 0.05;
    
    paddleAngleX += (targetAngleX - paddleAngleX) * 0.6;
    paddleAngleY += (targetAngleY - paddleAngleY) * 0.5;
    // Eƒüimi sƒ±nƒ±rla
    paddleAngleX = Math.max(-0.5, Math.min(0.5, paddleAngleX));
    paddleAngleY = Math.max(-0.3, Math.min(0.3, paddleAngleY));
    
    // Rakip AI
    if (gameState === 'playing' && ballVel.z < 0) {
        const timeToReach = Math.abs((oppPos.z - ballPos.z) / (ballVel.z || 0.1));
        let predictedX = ballPos.x + ballVel.x * timeToReach * 0.85;
        predictedX += ballSpin.z * timeToReach * 0.25;
        
        const aiSpeed = gameMode === 'practice' ? 0.025 : 0.05;
        oppPos.x += (predictedX - oppPos.x) * aiSpeed;
        oppPos.x = Math.max(-TABLE.width/2, Math.min(TABLE.width/2, oppPos.x));
    }
    
    // Ball physics during gameplay
    if (gameState === 'playing') {
        updateBall(dt);
    }
    
    // Ball physics during serve
    if (gameState === 'serving' && servingPlayer === 'player') {
        if (servePhase === 0) {
            // Top raket √∂n√ºnde bekler
            ballPos.x = paddlePos.x;
            ballPos.y = paddlePos.y + 0.1;
            ballPos.z = paddlePos.z - 0.12;
        } else if (servePhase === 1) {
            // Top atƒ±ldƒ± - yer√ßekimi uygula
            ballVel.y += PHYSICS.gravity * dt;
            ballPos.x += ballVel.x * dt;
            ballPos.y += ballVel.y * dt;
            ballPos.z += ballVel.z * dt;
            
            // Raket topa vuruyor mu? - B√úY√úK vuru≈ü alanƒ±
            const dist = Math.sqrt(
                (ballPos.x - paddlePos.x)**2 +
                (ballPos.y - paddlePos.y)**2 +
                (ballPos.z - paddlePos.z)**2
            );
            
            // Kolay vuru≈ü - geni≈ü alan
            if (dist < PHYSICS.paddleRadius + PHYSICS.ballRadius + 0.12) {
                playerServe();
            }
            
            // Top d√º≈üt√º - tekrar dene
            if (ballPos.y < TABLE.height - 0.15) {
                showMsg('‚ùå Ka√ßƒ±rdƒ±n! Tekrar dene.', 1500);
                setTimeout(prepareServe, 1200);
            }
        }
    }
    
    // Update meshes
    paddle.position.set(paddlePos.x, paddlePos.y, paddlePos.z);
    // Raket yatay duracak, eƒüim hareketle olacak
    paddle.rotation.set(0, 0, paddleAngleX);
    
    opponentPaddle.position.set(oppPos.x, oppPos.y, oppPos.z);
    opponentPaddle.rotation.set(Math.PI, 0, 0); // Rakip raketi ters
    
    ball.position.set(ballPos.x, ballPos.y, ballPos.z);
    ball.rotation.x += ballSpin.x * dt * 3;
    ball.rotation.y += ballSpin.y * dt * 3;
    ball.rotation.z += ballSpin.z * dt * 3;
}

function updateBall(dt) {
    // Yer√ßekimi
    ballVel.y += PHYSICS.gravity * dt;
    
    // Hava direnci
    ballVel.x *= PHYSICS.airResistance;
    ballVel.z *= PHYSICS.airResistance;
    
    // ===== MAGNUS ETKƒ∞Sƒ∞ (FALSO) =====
    const magnus = PHYSICS.magnusStrength;
    ballVel.x += ballSpin.z * magnus * dt;
    ballVel.z -= ballSpin.x * magnus * 0.4 * dt;
    ballVel.y += ballSpin.x * magnus * 0.25 * dt;
    
    // Spin azalmasƒ±
    ballSpin.x *= 0.996;
    ballSpin.y *= 0.996;
    ballSpin.z *= 0.996;
    
    // Pozisyon g√ºncelle
    ballPos.x += ballVel.x * dt;
    ballPos.y += ballVel.y * dt;
    ballPos.z += ballVel.z * dt;
    
    // ===== MASA SI√áRAMASI - MASA TENƒ∞Sƒ∞ KURALLARI =====
    if (ballPos.y <= TABLE.height + PHYSICS.ballRadius && ballVel.y < 0) {
        if (Math.abs(ballPos.x) <= TABLE.width/2 && Math.abs(ballPos.z) <= TABLE.length/2) {
            
            // Hangi b√∂lgede sekti?
            const zone = ballPos.z > 0 ? 'player' : 'opponent';
            
            // KURAL: Her alanda sadece 1 kez sekebilir
            if (zone === lastBounceZone) {
                // Aynƒ± alanda 2. kez sekti = FOUL
                if (zone === 'player') {
                    // Oyuncu tarafƒ±nda 2. sekme = rakip sayƒ±
                    showMsg('‚ö†Ô∏è 2. sekme! Rakip sayƒ±!', 1500);
                    score('opponent');
                    return;
                } else {
                    // Rakip tarafƒ±nda 2. sekme = oyuncu sayƒ±
                    showMsg('‚úÖ Rakip 2. sekme yaptƒ±!', 1500);
                    score('player');
                    return;
                }
            }
            
            lastBounceZone = zone;
            bounceCount[zone]++;
            
            // Sƒ±√ßrama fiziƒüi
            ballPos.y = TABLE.height + PHYSICS.ballRadius;
            ballVel.y = -ballVel.y * PHYSICS.bounce;
            
            // Spin etkisi
            ballVel.x += ballSpin.z * 0.12;
            ballVel.z -= ballSpin.x * 0.1;
            
            playSound(500);
        }
    }
    
    // File √ßarpmasƒ±
    if (Math.abs(ballPos.z) < 0.06 && ballPos.y < TABLE.height + TABLE.netHeight + PHYSICS.ballRadius && ballPos.y > TABLE.height) {
        // File'e deƒüdi
        ballVel.z *= -0.2;
        ballVel.y *= 0.4;
        ballPos.z = Math.sign(ballPos.z) * 0.07;
        playSound(200);
    }
    
    // ===== OYUNCU RAKET √áARPI≈ûMASI =====
    const pDist = Math.sqrt((ballPos.x-paddlePos.x)**2 + (ballPos.y-paddlePos.y)**2 + (ballPos.z-paddlePos.z)**2);
    const hitRadius = PHYSICS.paddleRadius + PHYSICS.ballRadius + 0.05;
    
    if (pDist < hitRadius && ballVel.z > 0 && lastHitter !== 'player') {
        lastHitter = 'player';
        lastBounceZone = null; // Vuru≈ütan sonra sekme sayacƒ± sƒ±fƒ±rla
        bounceCount = { player: 0, opponent: 0 };
        
        playSound(800);
        
        // Vuru≈ü pozisyonu
        const hitX = (ballPos.x - paddlePos.x) / PHYSICS.paddleRadius;
        const hitY = (ballPos.y - paddlePos.y) / PHYSICS.paddleRadius;
        
        // G√ú√á - UZAƒûA Gƒ∞TMELƒ∞
        const basePower = 4.0;  // Daha g√º√ßl√º vuru≈ü
        const swingPower = Math.min(Math.abs(paddleVel.z) * 0.2, 2.0);
        const totalPower = basePower + swingPower;
        
        // Y√∂n
        ballVel.x = hitX * 2.0 + paddleVel.x * 0.5;
        ballVel.y = 2.2;
        ballVel.z = -totalPower;
        
        // ===== FALSO Sƒ∞STEMƒ∞ =====
        const sideSpinFromMovement = -paddleVel.x * 0.5;
        const sideSpinFromAngle = paddleAngleX * 4;
        const topSpin = -paddleVel.y * 0.35;
        
        ballSpin.x = topSpin;
        ballSpin.y = 0;
        ballSpin.z = sideSpinFromMovement + sideSpinFromAngle;
    }
    
    // ===== RAKƒ∞P RAKET √áARPI≈ûMASI =====
    const oDist = Math.sqrt((ballPos.x-oppPos.x)**2 + (ballPos.y-oppPos.y)**2 + (ballPos.z-oppPos.z)**2);
    if (oDist < hitRadius && ballVel.z < 0 && lastHitter !== 'opponent') {
        lastHitter = 'opponent';
        lastBounceZone = null;
        bounceCount = { player: 0, opponent: 0 };
        
        playSound(800);
        
        // Rakip g√º√ßl√º vuru≈ü
        const targetX = (Math.random()-0.5) * TABLE.width * 0.7;
        const power = 3.5 + Math.random() * 1.0;
        
        ballVel.x = (targetX - ballPos.x) * 0.5;
        ballVel.y = 2.0;
        ballVel.z = power;
        
        // Rakip spin
        ballSpin.x = (Math.random()-0.5) * 3;
        ballSpin.z = (Math.random()-0.5) * 3;
    }
    
    // ===== SINIR DI≈ûI =====
    // Masanƒ±n arkasƒ±na ge√ßti (sekmeden)
    if (ballPos.z > TABLE.length/2 + 0.5 && lastBounceZone !== 'player') {
        showMsg('‚ùå Masana deƒümedi!', 1500);
        score('opponent');
        return;
    }
    if (ballPos.z < -TABLE.length/2 - 0.5 && lastBounceZone !== 'opponent') {
        showMsg('‚úÖ Rakip masasƒ±na deƒümedi!', 1500);
        score('player');
        return;
    }
    
    // Tamamen sƒ±nƒ±r dƒ±≈üƒ±
    if (ballPos.z > TABLE.length/2 + 2) { score('opponent'); return; }
    if (ballPos.z < -TABLE.length/2 - 2) { score('player'); return; }
    
    // Yere d√º≈üt√º
    if (ballPos.y < TABLE.height - 1.0) {
        if (lastHitter === 'player') {
            score('opponent');
        } else {
            score('player');
        }
        return;
    }
    
    // Yan dƒ±≈üarƒ± √ßƒ±ktƒ±
    if (Math.abs(ballPos.x) > TABLE.width + 1.5) {
        if (lastHitter === 'player') {
            score('opponent');
        } else {
            score('player');
        }
    }
}

function score(who) {
    if (gameState !== 'playing') return;
    gameState = 'scoring';
    
    scores[who]++;
    updateScore();
    playSound(who === 'player' ? 700 : 250);
    showMsg(who === 'player' ? '‚úÖ SAYIN!' : '‚ùå Rakip Sayƒ±!', 1500);
    
    if ((scores.player >= 11 || scores.opponent >= 11) && Math.abs(scores.player - scores.opponent) >= 2) {
        endGame();
        return;
    }
    
    servingPlayer = servingPlayer === 'player' ? 'opponent' : 'player';
    setTimeout(() => { if (gameState !== 'menu') prepareServe(); }, 2000);
}

function endGame() {
    gameState = 'ended';
    const won = scores.player > scores.opponent;
    showMsg(won ? 'üéâ KAZANDIN!' : 'üò¢ KAYBETTƒ∞N', 0);
    playSound(won ? 880 : 220);
    
    setTimeout(() => {
        document.getElementById('message').innerHTML += '<br><br><button class="menu-btn btn-bot" onclick="location.reload()">üîÑ Tekrar</button>';
    }, 500);
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused';
        document.getElementById('pause-screen').style.display = 'flex';
    } else if (gameState === 'paused') {
        gameState = 'playing';
        document.getElementById('pause-screen').style.display = 'none';
    }
}

function updateScore() {
    document.getElementById('score-p1').textContent = scores.player;
    document.getElementById('score-p2').textContent = scores.opponent;
}

function showMsg(text, duration) {
    const el = document.getElementById('message');
    el.innerHTML = text;
    el.style.display = 'block';
    if (duration) setTimeout(() => { if (gameState !== 'ended') el.style.display = 'none'; }, duration);
}

function playSound(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
}

// ===== ANIMATION =====
let lastTime = 0;
function animate(time) {
    requestAnimationFrame(animate);
    const dt = Math.min((time - lastTime) / 1000, 0.05) || 0.016;
    lastTime = time;
    update(dt);
    if (renderer) renderer.render(scene, camera);
}

// ===== BUTTON HANDLERS =====
document.getElementById('btn-bot').addEventListener('click', () => {
    console.log('Bot button clicked');
    gameMode = 'bot';
    startGame();
});

document.getElementById('btn-practice').addEventListener('click', () => {
    console.log('Practice button clicked');
    gameMode = 'practice';
    startGame();
});

document.getElementById('btn-online').addEventListener('click', () => {
    console.log('Online button clicked');
    alert('Online mod yakƒ±nda!');
});

document.getElementById('btn-resume').addEventListener('click', () => {
    gameState = 'playing';
    document.getElementById('pause-screen').style.display = 'none';
});

document.getElementById('btn-quit').addEventListener('click', () => {
    location.reload();
});

// ===== START =====
console.log('Script loaded');
init();
    </script>
</body>
</html>
