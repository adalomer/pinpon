<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèì 3D Ping Pong Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a3e 0%, #0a0a1a 100%);
            color: white;
            overflow: hidden;
            cursor: none;
        }
        
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Custom Cursor */
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #00f5ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: transform 0.1s, border-color 0.2s;
            box-shadow: 0 0 10px #00f5ff, inset 0 0 5px rgba(0,245,255,0.3);
        }
        
        #custom-cursor.hitting {
            transform: translate(-50%, -50%) scale(1.5);
            border-color: #ff00ff;
            box-shadow: 0 0 20px #ff00ff;
        }
        
        #menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: rgba(10, 10, 26, 0.97);
            backdrop-filter: blur(10px);
        }
        
        #menu-screen.hidden { display: none; }
        
        .title {
            font-size: 4rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00f5ff, #ff00ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0,245,255,0.5);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px #00f5ff); }
            to { filter: drop-shadow(0 0 40px #ff00ff); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 40px;
        }
        
        .menu-btn {
            display: block;
            width: 280px;
            padding: 18px 35px;
            margin: 12px;
            font-size: 1.3rem;
            font-weight: bold;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .menu-btn:hover {
            transform: scale(1.08) translateY(-3px);
        }
        
        .btn-bot {
            background: linear-gradient(135deg, #ff00ff, #ff0088);
            color: white;
            box-shadow: 0 5px 30px rgba(255, 0, 255, 0.5);
        }
        
        .btn-bot:hover {
            box-shadow: 0 10px 40px rgba(255, 0, 255, 0.7);
        }
        
        .btn-practice {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: black;
            box-shadow: 0 5px 30px rgba(0, 255, 136, 0.5);
        }
        
        .btn-practice:hover {
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.7);
        }
        
        .btn-online {
            background: linear-gradient(135deg, #00f5ff, #0088ff);
            color: black;
            box-shadow: 0 5px 30px rgba(0, 245, 255, 0.5);
        }
        
        .btn-online:hover {
            box-shadow: 0 10px 40px rgba(0, 245, 255, 0.7);
        }
        
        #game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 50;
            display: none;
            pointer-events: none;
        }
        
        #game-ui.active { display: block; }
        
        #score-board {
            display: flex;
            justify-content: center;
            gap: 80px;
            padding: 25px;
            font-size: 1.8rem;
        }
        
        .score { 
            text-align: center;
            padding: 15px 30px;
            border-radius: 15px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
        }
        
        .score-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0.8;
        }
        
        .score-value {
            font-size: 3.5rem;
            font-weight: bold;
            text-shadow: 0 0 20px currentColor;
        }
        
        .p1 { color: #00f5ff; border: 2px solid rgba(0,245,255,0.3); }
        .p2 { color: #ff00ff; border: 2px solid rgba(255,0,255,0.3); }
        
        /* Spin Indicator */
        #spin-indicator {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.2);
            z-index: 60;
            display: none;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        #spin-indicator.active { display: block; }
        
        #spin-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 6px;
            background: linear-gradient(90deg, #00f5ff, #ff00ff);
            transform-origin: left center;
            border-radius: 3px;
            box-shadow: 0 0 15px #00f5ff;
        }
        
        #spin-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #888;
        }
        
        /* Power Meter */
        #power-meter {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 30px;
            height: 150px;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.2);
            z-index: 60;
            display: none;
            background: rgba(0,0,0,0.5);
            overflow: hidden;
        }
        
        #power-meter.active { display: block; }
        
        #power-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #00ff88, #ffff00, #ff0000);
            transition: height 0.1s;
            box-shadow: 0 0 15px #00ff88;
        }
        
        #power-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #888;
        }
        
        /* Combo Counter */
        #combo {
            position: fixed;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 2rem;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            z-index: 60;
            display: none;
            animation: comboPulse 0.3s ease-out;
        }
        
        @keyframes comboPulse {
            0% { transform: translateY(-50%) scale(1.5); }
            100% { transform: translateY(-50%) scale(1); }
        }
        
        #message {
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            text-align: center;
            z-index: 60;
            display: none;
            text-shadow: 0 0 30px rgba(0,245,255,0.9);
            animation: msgAppear 0.3s ease-out;
        }
        
        @keyframes msgAppear {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        /* Tutorial */
        #tutorial {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #aaa;
            z-index: 55;
            display: none;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        #tutorial.active { display: block; }
        
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 3px 10px;
            border-radius: 5px;
            margin: 0 3px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .info {
            margin-top: 40px;
            color: #666;
            text-align: center;
            line-height: 2;
            font-size: 0.95rem;
        }
        
        .info strong {
            color: #00f5ff;
        }
        
        /* Hit Effect */
        .hit-effect {
            position: fixed;
            pointer-events: none;
            z-index: 500;
            animation: hitExpand 0.4s ease-out forwards;
        }
        
        @keyframes hitExpand {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="custom-cursor"></div>
    
    <div id="menu-screen">
        <h1 class="title">üèì PING PONG PRO</h1>
        <p class="subtitle">3D Masa Tenisi Sim√ºlasyonu</p>
        
        <button class="menu-btn btn-bot" id="btn-bot">ü§ñ Bota Kar≈üƒ±</button>
        <button class="menu-btn btn-practice" id="btn-practice">üéØ Antrenman</button>
        <button class="menu-btn btn-online" id="btn-online">üåê 2 Ki≈üilik</button>
        
        <div class="info">
            <strong>üñ±Ô∏è Fare Hareketi</strong> = Raket Kontrol√º<br>
            <strong>‚¨ÖÔ∏è Sola √áekerek Vur</strong> = Saƒüa Falso<br>
            <strong>‚û°Ô∏è Saƒüa √áekerek Vur</strong> = Sola Falso<br>
            <strong>‚¨ÜÔ∏è‚¨áÔ∏è Yukarƒ±/A≈üaƒüƒ±</strong> = Topspin/Backspin<br>
            <span class="key">SPACE</span> veya <span class="key">TIKLA</span> = Servis
        </div>
    </div>
    
    <div id="game-ui">
        <div id="score-board">
            <div class="score p1">
                <div class="score-label">Sen</div>
                <div class="score-value" id="score-p1">0</div>
            </div>
            <div class="score p2">
                <div class="score-label">Rakip</div>
                <div class="score-value" id="score-p2">0</div>
            </div>
        </div>
    </div>
    
    <div id="spin-indicator">
        <div id="spin-arrow"></div>
        <div id="spin-label">SPIN</div>
    </div>
    
    <div id="power-meter">
        <div id="power-fill"></div>
        <div id="power-label">G√ú√á</div>
    </div>
    
    <div id="combo"></div>
    <div id="message"></div>
    
    <div id="tutorial">
        <span class="key">SPACE</span> ile topu at, sonra <strong>raketinle vur!</strong>
    </div>
    
    <div id="pause-screen">
        <h2 style="font-size: 3rem; margin-bottom: 40px;">‚è∏Ô∏è DURAKLATILDI</h2>
        <button class="menu-btn btn-bot" id="btn-resume">‚ñ∂Ô∏è Devam Et</button>
        <button class="menu-btn btn-practice" id="btn-quit">üè† Ana Men√º</button>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script>
// ==================== 3D PING PONG ====================

let scene, camera, renderer;
let table, net, ball, paddle, opponentPaddle;
let gameState = 'menu';
let gameMode = 'bot';

const TABLE = { length: 3.5, width: 2, height: 0.76, netHeight: 0.15 };
const PHYSICS = { gravity: -8, ballRadius: 0.025, paddleRadius: 0.095, bounce: 0.85 };

let ballPos = { x: 0, y: TABLE.height + 0.2, z: 0.8 };
let ballVel = { x: 0, y: 0, z: 0 };
let ballSpin = { x: 0, z: 0 };

let paddlePos = { x: 0, y: TABLE.height + 0.12, z: TABLE.length/2 + 0.15 };
let paddlePrev = { x: 0, y: TABLE.height + 0.12, z: TABLE.length/2 + 0.15 };
let paddleVel = { x: 0, y: 0, z: 0 };
let paddleAngle = 0; // Raket eƒüim a√ßƒ±sƒ±

let oppPos = { x: 0, y: TABLE.height + 0.12, z: -TABLE.length/2 - 0.15 };

let mouse = { x: 0, y: 0 };
let scores = { player: 0, opponent: 0 };
let servingPlayer = 'player';
let servePhase = 0;
let audioCtx = null;

// ===== INIT =====
function init() {
    console.log('Init started');
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, TABLE.height + 1.5, TABLE.length/2 + 2.5);
    camera.lookAt(0, TABLE.height, -TABLE.length/4);
    
    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    
    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(3, 8, 5);
    light.castShadow = true;
    scene.add(light);
    
    createTable();
    createNet();
    createBall();
    createPaddles();
    createFloor();
    
    setupEvents();
    animate();
    
    console.log('Init complete');
}

function createTable() {
    const geo = new THREE.BoxGeometry(TABLE.width, 0.03, TABLE.length);
    const mat = new THREE.MeshStandardMaterial({ color: 0x0d6b32 });
    table = new THREE.Mesh(geo, mat);
    table.position.set(0, TABLE.height, 0);
    table.receiveShadow = true;
    scene.add(table);
    
    // Lines
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const centerLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.005, TABLE.length), lineMat);
    centerLine.position.set(0, TABLE.height + 0.02, 0);
    scene.add(centerLine);
}

function createNet() {
    // Posts
    const postGeo = new THREE.CylinderGeometry(0.01, 0.01, TABLE.netHeight);
    const postMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    [-1, 1].forEach(side => {
        const post = new THREE.Mesh(postGeo, postMat);
        post.position.set(side * (TABLE.width/2 + 0.02), TABLE.height + TABLE.netHeight/2, 0);
        scene.add(post);
    });
    
    // Net
    const netGeo = new THREE.BoxGeometry(TABLE.width + 0.04, TABLE.netHeight, 0.01);
    const netMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    net = new THREE.Mesh(netGeo, netMat);
    net.position.set(0, TABLE.height + TABLE.netHeight/2 + 0.015, 0);
    scene.add(net);
}

function createBall() {
    const geo = new THREE.SphereGeometry(PHYSICS.ballRadius, 32, 32);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.3 });
    ball = new THREE.Mesh(geo, mat);
    ball.castShadow = true;
    scene.add(ball);
}

function createPaddles() {
    const geo = new THREE.CylinderGeometry(PHYSICS.paddleRadius, PHYSICS.paddleRadius, 0.01, 32);
    
    // Player paddle
    const pMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
    paddle = new THREE.Mesh(geo, pMat);
    paddle.castShadow = true;
    scene.add(paddle);
    
    // Player handle - pointing toward player (positive Z)
    const handleGeo = new THREE.CylinderGeometry(0.012, 0.018, 0.12, 16);
    const handleMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
    const handle = new THREE.Mesh(handleGeo, handleMat);
    handle.position.set(0, 0, PHYSICS.paddleRadius + 0.05);
    paddle.add(handle);
    
    // Opponent paddle
    const oMat = new THREE.MeshStandardMaterial({ color: 0x0066cc });
    opponentPaddle = new THREE.Mesh(geo.clone(), oMat);
    opponentPaddle.castShadow = true;
    scene.add(opponentPaddle);
    
    // Opponent handle - pointing down (negative Y direction from paddle)
    const oppHandle = new THREE.Mesh(handleGeo.clone(), handleMat);
    oppHandle.position.set(0, 0, -(PHYSICS.paddleRadius + 0.05));
    opponentPaddle.add(oppHandle);
}

function createFloor() {
    const geo = new THREE.PlaneGeometry(20, 20);
    const mat = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
    const floor = new THREE.Mesh(geo, mat);
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);
}

// ===== EVENTS =====
function setupEvents() {
    document.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    
    document.addEventListener('click', () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (gameState === 'serving' && servingPlayer === 'player' && servePhase === 0) {
            tossBall();
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === ' ' && gameState === 'serving' && servingPlayer === 'player' && servePhase === 0) {
            tossBall();
        }
        if (e.key === 'Escape') togglePause();
    });
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// ===== GAME =====
function startGame() {
    console.log('Starting game');
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('game-ui').classList.add('active');
    
    scores = { player: 0, opponent: 0 };
    updateScore();
    servingPlayer = 'player';
    prepareServe();
}

function prepareServe() {
    gameState = 'serving';
    servePhase = 0;
    
    if (servingPlayer === 'player') {
        // Ball starts in front of paddle, ready to toss
        ballPos = { 
            x: paddlePos.x, 
            y: paddlePos.y + 0.08, 
            z: paddlePos.z - 0.15 
        };
        ballVel = { x: 0, y: 0, z: 0 };
        showMsg('üèì SPACE veya TIKLA = Topu at!', 3000);
    } else {
        ballPos = { x: oppPos.x, y: TABLE.height + 0.15, z: -TABLE.length/2 + 0.2 };
        ballVel = { x: 0, y: 0, z: 0 };
        showMsg('ü§ñ Rakip servis...', 1000);
        setTimeout(() => { if (gameState === 'serving') opponentServe(); }, 1200);
    }
}

function tossBall() {
    servePhase = 1;
    // Toss ball up and slightly forward
    ballVel = { x: 0, y: 4, z: -0.5 };
    playSound(400);
    showMsg('üéØ Raketi topa g√∂t√ºr!', 2000);
}

function playerServe() {
    servePhase = 2;
    gameState = 'playing';
    playSound(800);
    
    // Ball goes toward opponent with spin based on paddle movement
    const power = Math.min(5 + Math.abs(paddleVel.z) * 0.3, 8);
    ballVel = {
        x: paddleVel.x * 0.3 + (Math.random() - 0.5) * 0.5,
        y: 1.5,
        z: -power
    };
    ballSpin = { x: paddleVel.y * 0.3, z: paddleVel.x * 0.3 };
}

function opponentServe() {
    servePhase = 2;
    gameState = 'playing';
    playSound(800);
    
    ballVel = { x: (Math.random()-0.5)*2, y: -2, z: 3 };
    ballSpin = { x: (Math.random()-0.5)*3, z: (Math.random()-0.5)*3 };
}

function update(dt) {
    if (!dt || dt > 0.1) dt = 0.016;
    
    // Paddle - store previous
    paddlePrev.x = paddlePos.x;
    paddlePrev.y = paddlePos.y;
    paddlePrev.z = paddlePos.z;
    
    // X: left-right from mouse X - MORE RESPONSIVE
    const targetX = mouse.x * (TABLE.width/2 + 0.2);
    
    // Z: depth from mouse Y
    const minZ = TABLE.length/2 - 0.5;
    const maxZ = TABLE.length/2 + 0.35;
    const targetZ = maxZ - (mouse.y + 1) * 0.5 * (maxZ - minZ);
    
    // Y: height
    const targetY = TABLE.height + 0.1 + (1 - (mouse.y + 1) * 0.25) * 0.12;
    
    // SHARP movement - direct follow (0.4 = very responsive)
    paddlePos.x += (targetX - paddlePos.x) * 0.4;
    paddlePos.y += (targetY - paddlePos.y) * 0.4;
    paddlePos.z += (targetZ - paddlePos.z) * 0.4;
    
    // Clamp
    paddlePos.x = Math.max(-TABLE.width/2 - 0.2, Math.min(TABLE.width/2 + 0.2, paddlePos.x));
    paddlePos.y = Math.max(TABLE.height + 0.05, Math.min(TABLE.height + 0.3, paddlePos.y));
    paddlePos.z = Math.max(minZ, Math.min(maxZ, paddlePos.z));
    
    // Calculate velocity
    paddleVel.x = (paddlePos.x - paddlePrev.x) / dt;
    paddleVel.y = (paddlePos.y - paddlePrev.y) / dt;
    paddleVel.z = (paddlePos.z - paddlePrev.z) / dt;
    
    // PADDLE ANGLE based on mouse X position
    // Mouse right = paddle tilts right (handle goes left)
    // Mouse left = paddle tilts left (handle goes right)
    const targetAngle = -mouse.x * 0.4; // Max ~23 degrees tilt
    paddleAngle += (targetAngle - paddleAngle) * 0.3;
    
    // Opponent AI
    if (gameState === 'playing' && ballVel.z < 0) {
        const t = Math.abs((oppPos.z - ballPos.z) / ballVel.z);
        const targetX = ballPos.x + ballVel.x * t * 0.7;
        oppPos.x += (targetX - oppPos.x) * 0.05;
        oppPos.x = Math.max(-TABLE.width/2, Math.min(TABLE.width/2, oppPos.x));
    }
    
    // Ball physics during gameplay
    if (gameState === 'playing') {
        updateBall(dt);
    }
    
    // Ball physics during serve
    if (gameState === 'serving' && servingPlayer === 'player') {
        if (servePhase === 0) {
            // Ball follows paddle position
            ballPos.x = paddlePos.x;
            ballPos.y = paddlePos.y + 0.08;
            ballPos.z = paddlePos.z - 0.12;
        } else if (servePhase === 1) {
            // Ball tossed - apply gravity
            ballVel.y += PHYSICS.gravity * dt;
            ballPos.x += ballVel.x * dt;
            ballPos.y += ballVel.y * dt;
            ballPos.z += ballVel.z * dt;
            
            // Check if paddle hits tossed ball - LARGER hit area for easier serve
            const dist = Math.sqrt(
                (ballPos.x - paddlePos.x)**2 +
                (ballPos.y - paddlePos.y)**2 +
                (ballPos.z - paddlePos.z)**2
            );
            
            // Easier to hit - larger detection radius
            if (dist < PHYSICS.paddleRadius + PHYSICS.ballRadius + 0.08) {
                playerServe();
            }
            
            // Ball fell too low - reset serve
            if (ballPos.y < TABLE.height - 0.1) {
                showMsg('‚ùå Ka√ßƒ±rdƒ±n! Tekrar dene.', 1500);
                setTimeout(prepareServe, 1000);
            }
        }
    }
    
    // Update meshes
    paddle.position.set(paddlePos.x, paddlePos.y, paddlePos.z);
    // Paddle rotation: base rotation + tilt based on mouse position
    paddle.rotation.set(Math.PI/2, 0, paddleAngle);
    
    opponentPaddle.position.set(oppPos.x, oppPos.y, oppPos.z);
    opponentPaddle.rotation.set(Math.PI/2, 0, 0);
    
    ball.position.set(ballPos.x, ballPos.y, ballPos.z);
    ball.rotation.x += ballSpin.x * dt * 2;
    ball.rotation.z += ballSpin.z * dt * 2;
}

function updateBall(dt) {
    ballVel.y += PHYSICS.gravity * dt;
    ballVel.x *= 0.999;
    ballVel.z *= 0.999;
    
    // Spin effect on ball trajectory (Magnus effect)
    ballVel.x += ballSpin.z * 0.2 * dt;
    ballVel.z -= ballSpin.x * 0.2 * dt;
    ballSpin.x *= 0.998;
    ballSpin.z *= 0.998;
    
    ballPos.x += ballVel.x * dt;
    ballPos.y += ballVel.y * dt;
    ballPos.z += ballVel.z * dt;
    
    // Table bounce
    if (ballPos.y <= TABLE.height + PHYSICS.ballRadius && ballVel.y < 0) {
        if (Math.abs(ballPos.x) <= TABLE.width/2 && Math.abs(ballPos.z) <= TABLE.length/2) {
            ballPos.y = TABLE.height + PHYSICS.ballRadius;
            ballVel.y = -ballVel.y * PHYSICS.bounce;
            // Spin affects bounce direction
            ballVel.x += ballSpin.z * 0.08;
            ballVel.z -= ballSpin.x * 0.08;
            playSound(500);
        }
    }
    
    // Net
    if (Math.abs(ballPos.z) < 0.04 && ballPos.y < TABLE.height + TABLE.netHeight + PHYSICS.ballRadius && ballPos.y > TABLE.height) {
        ballVel.z *= -0.3;
        ballPos.z = Math.sign(ballPos.z) * 0.05;
        playSound(200);
    }
    
    // Player paddle collision
    const pDist = Math.sqrt((ballPos.x-paddlePos.x)**2 + (ballPos.y-paddlePos.y)**2 + (ballPos.z-paddlePos.z)**2);
    if (pDist < PHYSICS.paddleRadius + PHYSICS.ballRadius + 0.02 && ballVel.z > 0) {
        playSound(800);
        
        // Hit position on paddle
        const hitX = (ballPos.x - paddlePos.x) / PHYSICS.paddleRadius;
        
        // Base power - SLOWER for more control
        const basePower = 3.5;
        const extraPower = Math.min(Math.abs(paddleVel.z) * 0.15, 2);
        
        // Direction based on hit position and paddle angle
        ballVel.x = hitX * 2 + paddleVel.x * 0.25;
        ballVel.y = 2;
        ballVel.z = -(basePower + extraPower);
        
        // SPIN based on paddle movement direction
        // Moving right while hitting = ball spins and curves LEFT
        // Moving left while hitting = ball spins and curves RIGHT
        ballSpin.x = paddleVel.y * 0.15;  // Topspin/backspin from vertical movement
        ballSpin.z = -paddleVel.x * 0.25; // Sidespin - REVERSED for realistic curve
        
        // Add spin from paddle angle
        ballSpin.z += paddleAngle * 2;
    }
    
    // Opponent paddle collision
    const oDist = Math.sqrt((ballPos.x-oppPos.x)**2 + (ballPos.y-oppPos.y)**2 + (ballPos.z-oppPos.z)**2);
    if (oDist < PHYSICS.paddleRadius + PHYSICS.ballRadius + 0.02 && ballVel.z < 0) {
        playSound(800);
        
        // Opponent aims toward player's reachable area - SLOWER
        const targetX = (Math.random()-0.5) * TABLE.width * 0.5;
        ballVel.x = (targetX - ballPos.x) * 0.5;
        ballVel.y = 2;
        ballVel.z = 3 + Math.random() * 1.5; // Slower returns
        
        // Random spin
        ballSpin.x = (Math.random()-0.5) * 2;
        ballSpin.z = (Math.random()-0.5) * 2;
    }
    
    // Out of bounds
    if (ballPos.z > TABLE.length/2 + 1) { score('opponent'); return; }
    if (ballPos.z < -TABLE.length/2 - 1) { score('player'); return; }
    if (ballPos.y < TABLE.height - 0.5) {
        score(ballPos.z > 0 ? 'opponent' : 'player');
    }
}

function score(who) {
    if (gameState !== 'playing') return;
    gameState = 'scoring';
    
    scores[who]++;
    updateScore();
    playSound(who === 'player' ? 700 : 250);
    showMsg(who === 'player' ? '‚úÖ SAYIN!' : '‚ùå Rakip Sayƒ±!', 1500);
    
    if ((scores.player >= 11 || scores.opponent >= 11) && Math.abs(scores.player - scores.opponent) >= 2) {
        endGame();
        return;
    }
    
    servingPlayer = servingPlayer === 'player' ? 'opponent' : 'player';
    setTimeout(() => { if (gameState !== 'menu') prepareServe(); }, 2000);
}

function endGame() {
    gameState = 'ended';
    const won = scores.player > scores.opponent;
    showMsg(won ? 'üéâ KAZANDIN!' : 'üò¢ KAYBETTƒ∞N', 0);
    playSound(won ? 880 : 220);
    
    setTimeout(() => {
        document.getElementById('message').innerHTML += '<br><br><button class="menu-btn btn-bot" onclick="location.reload()">üîÑ Tekrar</button>';
    }, 500);
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused';
        document.getElementById('pause-screen').style.display = 'flex';
    } else if (gameState === 'paused') {
        gameState = 'playing';
        document.getElementById('pause-screen').style.display = 'none';
    }
}

function updateScore() {
    document.getElementById('score-p1').textContent = scores.player;
    document.getElementById('score-p2').textContent = scores.opponent;
}

function showMsg(text, duration) {
    const el = document.getElementById('message');
    el.innerHTML = text;
    el.style.display = 'block';
    if (duration) setTimeout(() => { if (gameState !== 'ended') el.style.display = 'none'; }, duration);
}

function playSound(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
}

// ===== ANIMATION =====
let lastTime = 0;
function animate(time) {
    requestAnimationFrame(animate);
    const dt = Math.min((time - lastTime) / 1000, 0.05) || 0.016;
    lastTime = time;
    update(dt);
    if (renderer) renderer.render(scene, camera);
}

// ===== BUTTON HANDLERS =====
document.getElementById('btn-bot').addEventListener('click', () => {
    console.log('Bot button clicked');
    gameMode = 'bot';
    startGame();
});

document.getElementById('btn-practice').addEventListener('click', () => {
    console.log('Practice button clicked');
    gameMode = 'practice';
    startGame();
});

document.getElementById('btn-online').addEventListener('click', () => {
    console.log('Online button clicked');
    alert('Online mod yakƒ±nda!');
});

document.getElementById('btn-resume').addEventListener('click', () => {
    gameState = 'playing';
    document.getElementById('pause-screen').style.display = 'none';
});

document.getElementById('btn-quit').addEventListener('click', () => {
    location.reload();
});

// ===== START =====
console.log('Script loaded');
init();
    </script>
</body>
</html>
